import { generateSchema } from './schemaService';

export const mapLocaleToWpmlLocale = (locale) => {
	const localeMap = {
		en: 'en-US',
		'en-US': 'en-US',
		en_US: 'en-US',
		ko: 'ko-KR',
		ja: 'ja-JP',
		fr: 'fr-FR',
		de: 'de-DE',
	};

	return localeMap[locale] || 'en-US';
};

/**
 * Remove trailing slash.
 *
 * @param {String} string
 * @returns {String}
 */
const removeTrailingSlash = (string) => {
	if (typeof string !== 'string') return '';

	return string.endsWith('/') ? string.substring(0, string.length - 1) : string;
};

/**
 * Get the SEO hreflang tags
 *
 * @param {String} basePath Website base path.
 * @param {Array<Object>} translatedPages The alternativ translations of the current page.
 *
 * @returns {Array<String>}
 */
export const genAlternateHreflang = (basePath, translatedPages = []) => {
	// Check argument type.
	const pages = !translatedPages || !Array.isArray(translatedPages) ? [] : translatedPages;

	// Reduce recursively the pages to a list of hreftags.
	const hreflangTags = pages.reduce((acc, page) => {
		const locale = page.locale?.locale;
		const uri = removeTrailingSlash(page.uri);

		acc.push(`
			<link
				rel="alternate"
				href="${basePath}${uri}"
				hreflang="${locale?.replace('_', '-').replace('ko-KO', 'ko-KR').replace('ja-JA', 'ja-JP')}"
			/>
		`);
		return acc;
	}, []);

	let defaultPage = null;
	if (pages.length === 1) defaultPage = pages[0];
	else defaultPage = pages.find((p) => p.locale.locale === 'en_US' || p.locale.locale === 'en-US');

	if (defaultPage) {
		const uri = removeTrailingSlash(defaultPage.uri);
		hreflangTags.push(`<link rel="alternate" href="${basePath}${uri}" hreflang="x-default" />`);
	}
	// Exclude potential duplicated tags by using a Set object.
	return Array.from(new Set(hreflangTags)).sort();
};

/**
 * Get a modified html head.
 *
 * @param {Array<String>} tags Array of SEO tags generated by YOAST.
 * @param {String} pageType SEO page type. Ex.: 'webPage', 'article', 'products', etc.
 *
 * @returns {Array<String>}
 */
export const getHtmlHead = (tags = [], pageType = 'webPage') => {
	let htmlHead = [];
	if (!Array.isArray(tags)) return htmlHead;

	tags.forEach((tag) => {
		const type = tag.type;
		switch (type) {
			case 'title':
				htmlHead.push(`<title>${tag.props.children}</title>`);
				break;
			case 'name':
				htmlHead.push(`<meta name="robots" content="${tag.props.content}">`);
				break;
			case 'link':
				htmlHead.push(
					`<link rel="${tag.props.rel}"  ${tag.props.hrefLang ? `hreflang="${tag.props.hrefLang}"` : ''} href="${
						tag.props.href
					}">`
				);
				break;
			case 'meta':
				if (tag.props.hasOwnProperty('name')) {
					htmlHead.push(`<meta name="${tag.props.name}" content="${tag.props.content}">`);
					break;
				} else if (tag.props.hasOwnProperty('property')) {
					htmlHead.push(`<meta property="${tag.props.property}" content="${tag.props.content}">`);
					break;
				}
				break;
			case 'script':
				if (tag.props?.type === 'application/ld+json') {
					// TODO: generateSchema('article'... get dinamicaly the schema type based on post category.
					htmlHead.push(`<script type="${tag.props.type}" class="${tag.props.className}">
							${generateSchema(pageType, tag.props.dangerouslySetInnerHTML.__html)}
						</script>`);
				}
				break;
		}
	});

	return htmlHead;
};

/**
 * Criteria for filtering the SEO tags out of the html head.
 * @param {String} tag HTML SEO tag
 * @param {String} pageType SEO page type. Ex.: 'webPage', 'article', 'products', etc.
 * @returns {Boolean}
 */
export const filterHTMLHeadCriteria = (tag = '', pageType = 'webPage') => {
	// if (pageType === 'article' && tag.includes('property="')) return false;

	return true;
};

export default getHtmlHead;
