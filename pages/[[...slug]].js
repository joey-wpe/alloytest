import { useEffect } from 'react';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';
import { getGlobalSettings } from '../wplib/globalSettings';
import { getRevalidateOptions, handleInvalidDataResponse } from '../wplib/util';
import { convertWPLocaleToNextJSLocale, popUrlSegmentsForPathAndLanguages } from '../wplib/util';
import { getPageTemplateDataByDatabaseID, getAllPagesBasic, getPageDatabaseIDFromUri } from '../wplib/pages';
import BasePageWrapper from '../components/page-templates/BasePageWrapper/BasePageWrapper';
import PageTemplateSelector from '../components/page-templates/PageTemplateSelector/PageTemplateSelector';
import StringConstants from '../StringConstants';
import { transformToFooterStructure } from '../components/template-parts/Footer/Footer.datamediator';
import { pageHeaderToGlobalAlert } from '../data-mediators/PageHeaderToGlobalAlertMediator';
import { globalSettingsAndPageFooterToPageCTAData } from '../data-mediators/PageFooterAndSettingsToPageCTA';
import { mainMenuToMenu } from '../components/template-parts/Header/Header.datamediator';
import GlobalConstants from '../GlobalConstants';
import { getPostsFromJson } from '../wplib/util';
import { taxSelector } from '../components/page-templates/ArchiveTemplate/ArchiveTemplateTaxSelector';
import { parsePostTypes } from '../components/page-templates/ArchiveTemplate/ArchiveTemplateTaxSelector';

// NOTE:: this method is called with data from getStaticProps for a specific route (as generated by getStaticPaths())
export default function Page({
	page,
	postTypeData,
	globalAlertData,
	pageCTAData,
	footerMenu,
	menu /*, breadcrumbs */,
}) {
	const { uri, title, seo } = page;
	console.log(`[[...slug]].Page() - rendering page [template: ${page.template?.templateName}]: ${uri}`);

	if (typeof page.template === 'undefined') {
		console.error(
			'[[...slug]].Page() - page.template is undefined, this may happen if preview data is empty (ex: an unauthed request for preview data)'
		);
	}

	return (
		<>
			<BasePageWrapper title={title ?? ''} seoData={seo} translatedPages={menu?.translatedPages}>
				<PageTemplateSelector
					templateName={page.template.templateName}
					pageData={page}
					postTypeData={postTypeData}
					pageCTAData={pageCTAData}
					globalAlertData={globalAlertData}
					headerMenuData={menu}
					footerMenu={footerMenu}
				/>
			</BasePageWrapper>
		</>
	);
}

// we want to manipulate our response data here, so internal components are not dependent on knowledge of the underlying
// data, and so that the JavaScript effort is during build time and not runtime
export async function getStaticProps(context = {}) {
	const slug = context?.params.slug;

	/* NOTE::
	slug is an array of url segments,
	check if greater than 2 in order to test if second to last segment is 'page',					
	the last segment is the page number if it exists
	*/
	let paginatedPage = slug?.length > 2 && slug[slug.length - 2] === 'page' ? slug[slug.length - 1] : null;
	const isPreview = Boolean(context?.preview); // force to boolean
	var databaseID = -1;
	var token = null;
	const locale = context.locale;
	const pageLocaleSuffix = locale === 'en-US' ? '' : `-${locale}`;

	if (isPreview) {

		context.res?.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0');
        context.res?.setHeader('Pragma', 'no-cache');
        context.res?.setHeader('Expires', '0');
		// if we're previewing then we already know the ID
		databaseID = context?.previewData?.id;
		token = context?.previewData?.token;
		// console.log('[[]...slug]].getStaticProps() - databaseID (from preview route)', databaseID);
	} else {
		// if we're not previewing, then we need to lookup the ID from the Uri
		// generate the pageUri from the slug array
		var pageUri = context.locale === 'en-US' ? `/` : `/${context.locale}/`; // what will be queried for for page specific data
		if (Array.isArray(slug) && slug.length > 0) {
			pageUri = paginatedPage
				? `${pageUri}${slug.slice(0, slug.length - 2).join('/')}/`
				: `${pageUri}${slug.join('/')}/`;
		}

		// handle translated homepages
		const nonEnglishLocales = GlobalConstants.Locales.filter((locale) => locale !== 'en');

		for (const locale of nonEnglishLocales) {
			if (`/${locale}/` === pageUri) {
				pageUri = `/${locale}/homepage/`;
				break;
			}
		}

		try {
			// console.log('[[...slug]].getStaticProps() - looking up database id for pageUri: ', pageUri);
			databaseID = await getPageDatabaseIDFromUri(pageUri);
			if (!databaseID) {
				console.error(
					`[[...slug]].getStaticProps() - error getting databaseID from pageUri - pageUri doesn't exist: ${pageUri}, returning notFound`
				);
				return {
					notFound: true,
				};
			}
		} catch (err) {
			console.error(
				`[[...slug]].getStaticProps() - exception getting databaseID from pageUri: ${pageUri}, failing build`,
				err
			);
			throw err;
		}
	}

	// get global data (ex: menus, etc.) that doesn't change per page
	const { globalSettings, menus } = await getGlobalSettings(isPreview, context.locale);
	const mediatedFooterMenu = transformToFooterStructure(menus, globalSettings, context.locale);

	// NOTE:: getting previews only works for IDs and DatabaseIds (ref: https://github.com/patronage/bubs-next/issues/125)
	// as such, we need to get page data by database ID when in preview mode
	let page, postTypeData, translated;
	try {
		({ page, postTypeData, translated } = await getPageTemplateDataByDatabaseID(
			databaseID,
			isPreview,
			token,
			context.locale
		));
	} catch (error) {
		console.log(`[slug].getStaticProps() - error while fetching page`, error);
		return handleInvalidDataResponse(error);
	}

	// NOTE::: The ROI Calculator Main template must query it's header in a different way, so we read the header data out differently
	var pageHeader = page.pageHeader;
	if (page.template?.templateName === StringConstants.PageTemplates.ROICalculatorMain) {
		pageHeader = page.template.pageHeaderROICalculatorMain;
	}

	const menu = mainMenuToMenu(menus, globalSettings, translated, context.locale);

	// determine our global alert settings based off global settings and page settings
	const globalAlertData = pageHeaderToGlobalAlert(globalSettings, pageHeader);
	const pageCTAData = globalSettingsAndPageFooterToPageCTAData(globalSettings, page.pageFooter);

	const revalidateOptions = getRevalidateOptions();

	// get resource template post data
	if (
		page.template?.templateName === StringConstants.PageTemplates.Archive ||
		page.template?.templateName === StringConstants.PageTemplates.CaseStudiesMain ||
		page.template?.templateName === StringConstants.PageTemplates.Partners
	) {
		const postType = (() => {
			switch (page.template?.templateName) {
				case StringConstants.PageTemplates.Archive:
					return page.template.contentBlocksArchive?.postSection.postTypes.postType;
				case StringConstants.PageTemplates.CaseStudiesMain:
					return 'case_study';
				case StringConstants.PageTemplates.Partners:
					return 'partner';
				default:
					return null;
			}
		})();
		const taxAcf = page.template.contentBlocksArchive?.postSection?.taxonomies;
		const parsedPostTypes = parsePostTypes(postTypeData, postType);
		const taxParams = taxSelector(postType, parsedPostTypes, taxAcf);
		const taxonomies =
			taxParams.length > 0
				? taxParams.map((tax) => {
						return tax.term;
				  })
				: [];

		if (paginatedPage === null) {
			paginatedPage = 1;
		}

		const posts = await getPostsFromJson(
			postType,
			pageLocaleSuffix,
			taxonomies,
			'',
			paginatedPage,
			GlobalConstants.Archive.ResultsPerPage
		);

		postTypeData.paginatedPosts = {
			...posts,
			currentPage: parseInt(paginatedPage),
		};
	}

	page = {
		...page,
		locale: locale,
	};

	return {
		props: {
			page,
			postTypeData,
			globalAlertData,
			pageCTAData,
			footerMenu: mediatedFooterMenu,
			menu,
			...(await serverSideTranslations(context.locale, ['common'])),
			/* breadcrumbs, */
		},
		...revalidateOptions,
	};
}

// NOTE:: getStaticPaths always runs server side (ref: https://nextjs.org/docs/basic-features/data-fetching/get-static-paths)
export async function getStaticPaths({ locales }) {
	// if the flag is set, do a build only - no building of actual pages
	if (process.env.NO_PRERENDERED_PATHS_FALLBACK_ONLY === 'on') {
		return {
			paths: [],
			fallback: 'blocking',
		};
	}

	const nonEnglishLocales = GlobalConstants.Locales.filter((locale) => locale !== 'en');

	const { pages } = await getAllPagesBasic();

	let allPaginatedPages = [];
	const paths = await Promise.all(
		pages
			.filter((page) => {
				if (typeof page.uri !== 'string') {
					return false;
				}

				// The homepage will come through as /homepage and we want to exclude it
				if (nonEnglishLocales.find((locale) => page.uri === `/${locale}/homepage/`)) {
					return false;
				}

				// only include certain templates
				if (
					page.template?.templateName !== StringConstants.PageTemplates.ProductLogin &&
					page.template?.templateName !== StringConstants.PageTemplates.BasicOneColumn &&
					page.template?.templateName !== StringConstants.PageTemplates.Locations &&
					page.template?.templateName !== StringConstants.PageTemplates.Modular &&
					page.template?.templateName !== StringConstants.PageTemplates.NewsroomMain &&
					page.template?.templateName !== StringConstants.PageTemplates.Partners &&
					page.template?.templateName !== StringConstants.PageTemplates.ProductDemoForm &&
					page.template?.templateName !== StringConstants.PageTemplates.PricingMain &&
					page.template?.templateName !== StringConstants.PageTemplates.PricingDetail &&
					page.template?.templateName !== StringConstants.PageTemplates.TeamMemberArchive &&
					page.template?.templateName !== StringConstants.PageTemplates.ModularWithSecondaryNav &&
					page.template?.templateName !== StringConstants.PageTemplates.CaseStudiesMain &&
					page.template?.templateName !== StringConstants.PageTemplates.Archive &&
					page.template?.templateName !== StringConstants.PageTemplates.ROICalculatorMain &&
					page.template?.templateName !== StringConstants.PageTemplates.ROICalculatorResult
				) {
					console.warn(
						`[[...slug]].getStaticPaths() - excluding page (${page.uri}) with template (${page.template?.templateName})`
					);
					return false;
				}

				return true;
			})
			.map(async (pageEntry) => {
				// console.log('pageEntry', pageEntry);
				var segments = pageEntry.uri.split('/').filter((seg) => seg !== '');
				segments = popUrlSegmentsForPathAndLanguages(segments);

				// NOTE:: it was seen where a bad duplicate with WPML could cause a page with no locale
				// the build should fail in the case so it is caught, but we will log the page to help find
				if (!pageEntry.locale?.locale) {
					console.error('Locale was not set for page - build will fail!', pageEntry);
				}

				const pageLocale = convertWPLocaleToNextJSLocale(pageEntry.locale.locale);
				const pageLocaleSuffix = pageLocale === 'en-US' ? '' : `-${pageLocale}`;

				if (
					pageEntry.template?.templateName === StringConstants.PageTemplates.Archive ||
					pageEntry.template?.templateName === StringConstants.PageTemplates.CaseStudiesMain ||
					pageEntry.template?.templateName === StringConstants.PageTemplates.Partners
				) {
					let { page: pageData, postTypeData } = await getPageTemplateDataByDatabaseID(
						pageEntry.databaseId,
						false,
						null,
						pageLocale
					);
					const postType = (() => {
						switch (pageEntry.template?.templateName) {
							case StringConstants.PageTemplates.Archive:
								return pageData.template.contentBlocksArchive?.postSection.postTypes.postType;
							case StringConstants.PageTemplates.CaseStudiesMain:
								return 'case_study';
							case StringConstants.PageTemplates.Partners:
								return 'partner';
							default:
								return null;
						}
					})();
					const taxAcf = pageData.template.contentBlocksArchive?.postSection?.taxonomies;
					const parsedPostTypes = parsePostTypes(postTypeData, postType);
					const taxParams = taxSelector(postType, parsedPostTypes, taxAcf);
					const taxonomies = taxParams.length > 0 ? taxParams.map((param) => param.term) : [];

					const posts = await getPostsFromJson(
						postType,
						pageLocaleSuffix,
						taxonomies,
						'',
						1,
						GlobalConstants.Archive.ResultsPerPage
					);
					const numPaginatedPages = Math.ceil(posts.total_posts_found / GlobalConstants.Archive.ResultsPerPage);
					const paginatedPageList = Array.from({ length: numPaginatedPages }, (_, i) => ({
						params: {
							slug: [...segments, `page`, `${i + 1}`],
						},
						locale: pageLocale,
					}));

					allPaginatedPages.push(...paginatedPageList);
				}

				return {
					params: {
						slug: segments,
					},
					locale: pageLocale,
				};
			})
	);

	paths.push(...allPaginatedPages);

	// we want to explicitly add the translated homepages to our collection - they are excluded as /homepage in the filter above
	nonEnglishLocales.forEach((locale) => {
		paths.push({
			params: {
				slug: [],
			},
			locale: locale,
		});
	});

	// console.log('[[...slug]] paths', JSON.stringify(paths));
	return {
		paths,
		fallback: false,
	};
}
