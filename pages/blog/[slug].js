import { useRouter } from 'next/router';
import { useTranslation } from 'next-i18next';

import { getGlobalSettings } from '../../wplib/globalSettings';
import { getRevalidateOptions, handleInvalidDataResponse } from '../../wplib/util';
import GlobalConstants from '../../GlobalConstants';
import { convertWPLocaleToNextJSLocale, popUrlSegmentsForPathAndLanguages } from '../../wplib/util';
import {
	getAllBlogs,
	getRecentBlogs,
	getPublishedBlogDataBySlug,
	getPreviewBlogDataByDatabaseID,
} from '../../wplib/blogs';
import BasePageWrapper from '../../components/page-templates/BasePageWrapper/BasePageWrapper';
import BlogTemplate from '../../components/page-templates/BlogTemplate/BlogTemplate';
import StickyDisruptor from '../../components/atoms/StickyDisruptor/StickyDisruptor';
import { transformToFooterStructure } from '../../components/template-parts/Footer/Footer.datamediator';
import { pageHeaderToGlobalAlert } from '../../data-mediators/PageHeaderToGlobalAlertMediator';
import { stickyDisruptorData } from '../../data-mediators/StickyDisruptorResponseToStickyDisruptor';
import { mainMenuToMenu } from '../../components/template-parts/Header/Header.datamediator';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';
import { getAllBlogCategories } from '../../wplib/blogs';

// NOTE:: this method is called with data from getStaticProps for a specific route (as generated by getStaticPaths())
export default function Page({ slug, postTypeData, post, globalAlertData, footerMenu, menu, categories }) {
	const router = useRouter();
	const { t } = useTranslation('common');

	const {
		title,
		seo,
		templateBlog: { stickyDisruptor },
	} = post;
	const displayDisruptor = stickyDisruptor.stickyDisruptorDisplay === 'yes';

	const locale = router.locale === 'en-US' ? '' : `/${router.locale}`;

	// Add breadcrumb links Home > Blog > Category > Blog Name
	let breadcrumb = {
		breadcrumbsLinks: [
			{ label: t('breadcrumb.home'), url: `${locale}` },
			{ label: 'Blog', url: `${locale}/blog` },
		],
	};

	// Check if category exists before adding it to the breadcrumb
	if (post.categories.nodes.length > 0) {
		const primaryCategory = post.categories.nodes.find((cat) => cat.isPrimary);
		const category = primaryCategory ? primaryCategory : post.categories.nodes[0];

		breadcrumb.breadcrumbsLinks.push({
			label: category.name,
			url: `${locale}/blog/category/${category.slug}`,
		});
	}
	breadcrumb.breadcrumbsLinks.push({ label: post.title, url: `${locale}/blog/${post.slug}` });

	console.log(`blog/[slug].Page() - rendering blog post: ${GlobalConstants.FrontendRoutes.Blog}/${slug}`);
	return (
		<BasePageWrapper
			title={title ?? ''}
			seoData={seo}
			translatedPages={menu?.translatedPages}
			breadcrumbSchemaList={breadcrumb}
		>
			<>
				{displayDisruptor ? <StickyDisruptor {...stickyDisruptorData(stickyDisruptor)} /> : null}
				<BlogTemplate
					pageData={post}
					globalAlertData={globalAlertData}
					headerMenuData={menu}
					footerMenu={footerMenu}
					postTypeData={postTypeData}
					breadcrumb={breadcrumb}
				/>
			</>
		</BasePageWrapper>
	);
}

export async function getStaticProps(context = {}) {
	// console.log('blog/[slug].getStaticProps() - context', context);

	const slug = [context?.params.slug];
	const isPreview = Boolean(context?.preview); // force to boolean
	var databaseID = isPreview ? context?.previewData?.id : null;
	var token = isPreview ? context?.previewData?.token : null;

	// get global data (ex: menus, etc.) that doesn't change per page
	const { globalSettings, menus } = await getGlobalSettings(isPreview, context.locale);
	const mediatedFooterMenu = transformToFooterStructure(menus, globalSettings, context.locale);

	// get details from WP
	let post,
		postTypeData,
		translated = null;

	try {
		if (isPreview) {
			({ post, postTypeData, translated } = await getPreviewBlogDataByDatabaseID(databaseID, token, context.locale));
		} else {
			({ post, postTypeData, translated } = await getPublishedBlogDataBySlug(slug, context.locale));
		}
	} catch (error) {
		console.log(`blog/[slug].getStaticProps() - error while fetching post`, error);
		return handleInvalidDataResponse(error);
	}

	const menu = mainMenuToMenu(menus, globalSettings, translated, context.locale);

	// determine our global alert settings based off global settings and page settings
	const globalAlertData = pageHeaderToGlobalAlert(globalSettings, post.pageHeader);

	const revalidateOptions = getRevalidateOptions();
	let categories = await getAllBlogCategories();

	return {
		props: {
			slug,
			post,
			postTypeData,
			globalAlertData,
			footerMenu: mediatedFooterMenu,
			menu,
			categories,
			...(await serverSideTranslations(context.locale, ['common'])),
		},
		...revalidateOptions,
	};
}

// NOTE:: getStaticPaths always runs server side (ref: https://nextjs.org/docs/basic-features/data-fetching/get-static-paths)
export async function getStaticPaths() {
	// if the flag is set, do a build only - no building of actual pages
	if (process.env.NO_PRERENDERED_PATHS_FALLBACK_ONLY === 'on') {
		console.info(
			`blog/[slug].getStaticPaths() - NO_PRERENDERED_PATHS_FALLBACK_ONLY is on, not pre-generating any paths`
		);
		return {
			paths: [],
			fallback: 'blocking',
		};
	}

	var posts;
	if (process.env.SELECTIVE_PRERENDER === 'on') {
		console.info(
			`blog/[slug].getStaticPaths() - limited build - only getting latest ${GlobalConstants.Options.BlogPartialLimit} blogs`
		);
		posts = await getRecentBlogs();
	} else {
		posts = await getAllBlogs();
	}

	const paths = posts.map((post) => {
		// console.log('blog', blog);
		var segments = post.uri.split('/').filter((seg) => seg !== '');
		segments = popUrlSegmentsForPathAndLanguages(segments, GlobalConstants.FrontendRoutes.Blog);

		let pageLocale = convertWPLocaleToNextJSLocale(post.wpml_current_locale);

		return {
			params: {
				slug: segments[0],
			},
			locale: pageLocale,
		};
	});

	// console.log('blog paths', JSON.stringify(paths));
	return {
		paths,
		fallback: false,
	};
}
